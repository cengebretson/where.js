{
  "name": "where.js",
  "version": "0.1.1",
  "description": "data-driven test method for JavaScript test libraries",
  "homepage": "https://github.com/dfkaye/where.js",
  "author": {
    "name": "david kaye",
    "email": "dfkaye@yahoo.com",
    "url": "@dfkaye"
  },
  "contributors": [
    {
      "name": "Johann Sonntagbauer",
      "email": "johann.sonntagbauer@gmx.at"
    },
    {
      "name": "Jason Karns",
      "email": "jason@karns.name"
    },
    {
      "name": "Jamon Holmgren",
      "email": "jamon@clearsightstudio.com"
    },
    {
      "name": "Casey Watson",
      "email": "watsoncj@gmail.com"
    }
  ],
  "keywords": [
    "where",
    "where-data",
    "data-table",
    "data-driven",
    "jasmine",
    "mocha",
    "nodeunit",
    "qunit",
    "tape",
    "testem"
  ],
  "license": "JSON",
  "main": "./where.js",
  "devDependencies": {
    "chai": ">= 1.x",
    "expect.js": ">= 0.2",
    "mocha": ">= 1.7",
    "jasmine-node": "1.x.x",
    "nodeunit": ">= 0.8.6",
    "qunitjs": ">= 1.13",
    "qunit-tap": ">= 1.4",
    "should": ">= 3.0.1",
    "tape": ">= 2.3.2"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dfkaye/where.js.git"
  },
  "scripts": {
    "test": "jasmine-node --verbose ./test/where/where.spec.js",
    "jasmine": "jasmine-node --verbose --matchall ./test/jasmine/where-spec.js",
    "mocha": "node ./test/mocha/node-suite.js",
    "nodeunit": "node ./test/nodeunit/node-suite.js",
    "qunit": "node ./test/qunit/node-suite.js",
    "tape": "node ./test/tape/node-suite.js",
    "testem": "testem -l where -t ./test/where/browser-suite.html",
    "testem-jasmine": "testem -l jasmine -t ./test/jasmine/browser-suite.html",
    "testem-mocha": "testem -l mocha -t ./test/mocha/browser-suite.html",
    "testem-nodeunit": "testem -l nodeunit -t ./test/nodeunit/browser-suite.html",
    "testem-qunit": "testem -l qunit -t ./test/qunit/browser-suite.html",
    "testem-tape": "testem -l tape -t ./test/tape/browser-suite.html"
  },
  "readme": "[![Build Status](https://travis-ci.org/dfkaye/where.js.png?branch=master)](https://travis-ci.org/dfkaye/where.js)\n\n# where.js\n\nProvides data-table support in JavaScript tests.\n\nMostly ready for prime time, though still some things [to do](#TODO).\n\n## inspired by:\n+ Cucumber [`scenario-outlines`](https://github.com/cucumber/cucumber/wiki/Scenario-Outlines)\n+ Spock [`where:` blocks](https://code.google.com/p/spock/wiki/SpockBasics#Where_Blocks)\n+ JP Castro's (@jphpsf)[DRYing Up Your JavaScript Jasmine Tests With the Data Provider Pattern](http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests)\n+ Richard Rodger's (@rjrodger) [mstring](https://github.com/rjrodger/mstring)\n\n## see also\n+ [data-driven](https://github.com/fluentsoftware/data-driven), an extension for \n  mocha.js\n\n## contributors\n\n+ [Johann Sonntagbauer](https://github.com/johann-sonntagbauer)\n+ [Jason Karns](https://github.com/jasonkarns)\n+ [Jamon Holmgren](https://github.com/jamonholmgren)\n+ [Casey Watson](https://github.com/watsoncj)\n\n## license\n\nJSON\n\n## libraries tested and supported so far\n+ [jasmine](http://jasmine.github.io/) (v2.0.0 on browser)\n  - [jasmine-node](https://github.com/mhevery/jasmine-node) which uses v1.3.1\n+ [mocha](http://visionmedia.github.io/mocha/)\n  - `assert` (on node.js) and [assert.js](https://github.com/Jxck/assert) in the\n    browser\n  - [expect.js](https://github.com/LearnBoost/expect.js)\n  - [should.js](https://github.com/visionmedia/should.js)\n  - [chai](http://chaijs.com/) (assert, expect, should)\n+ [nodeunit](https://github.com/caolan/nodeunit)\n+ [QUnit](http://qunitjs.com/)\n+ [tape](https://github.com/substack/tape) @substack's event-driven TDD-flavored \n  TAP project for [testling](http://ci.testling.com/)\n\n## works on my machine...\n\nSee the [tests](#tests)...\n  \n## install\n\n    npm install where.js\n    \nor\n\n    git clone https://github.com/dfkaye/where.js.git\n  \n## important: global assignment\n\nRunning `where.js` adds a `where()` method to the **global** namespace - \n([__here's why__](https://gist.github.com/dfkaye/9129150), if you're curious...)\n\nnode.js:\n\n    require('where.js');\n    \n    assert(typeof where === 'function');\n    // => true\n    assert(typeof global.where === 'function');\n    // => true\n\nbrowsers:\n\n    <script src=\"[path/to]/where.js\"></script>\n\n    assert(typeof where === 'function');\n    // => true\n    assert(typeof window.where === 'function');\n    // => true\n    \n\n# justify\n\nEasier to read and modify this\n    \n    it('description', function () {\n      where(function(){\n        /*** \n          a  |  b  |  c\n          1  |  2  |  3\n          4  |  3  |  7\n          6  |  6  |  12\n        ***/\n        expect(a + b).toBe(c);\n      });\n    });\n\nthan this\n\n    it('description', function () {\n      [[1, 2, 3],\n       [4, 3, 7],\n       [6, 6, 12]].forEach(function(row, r, rows) {\n               \n        expect(Number(row[0]) + Number(row[1])).toBe(Number(row[2]));\n      });\n    });\n    \nwhere.js merges methods and lessons learned from my earlier \n[jasmine-where](https://github.com/dfkaye/jasmine-where) \nand [jasmine-intercept](https://github.com/dfkaye/jasmine-intercept) projects, \nwhich are now __deprecated__ as of this release.\n\n\n## where(fn, context) ~ arguments\n\n### {Function} fn\n\nIn imitation of Richard Rodger's [mstring](https://github.com/rjrodger/mstring), \n`where()` accepts a function and inspects its string value, converts the \ncommented data-table into an array of values, and applies the first row data as \nargument names in a new Function().\n\nThe function's body should contain an expectation or assertion statement.\n\nIf your JavaScript runtime supports ES65 strict mode, an undeclared variable in \nthe function body will result in an error.\n\n### {Object} context\n\n`where()` accepts a second argument, an context specifier, that allows you to \ninject other information or references into the test function, namely any \nreferences to your test library (jasmine, QUnit, etc.) and methods, variables \nthat are defined outside of the current test (in setup or before calls, for \nexample), and flags for logging or intercepting results to the console.\n\nSee more details about the [`context`](#context) argument.\n\n## multi-line comments\n\nA data table inside a where() function should be enclosed between start `/***` \nand end `***/` 3-asterisk comments.\n\n      where(function(){\n        /***        // start\n         a | b | c\n         1 | 2 | 2\n         4 | 3 | 4\n         6 | 6 | 6\n        ***/        // end\n        \n        expect(Math.max(a, b)).toBe(c);\n      });\n\n__aside__ where.js is a *testing* module and is not intended to be run through a \npre-production minifer such as google closure or uglify, both of which remove \nthe comments.\n\n### CoffeeScript comments\n\nIf you're writing tests in CoffeeScript, see the \n[CoffeeScript format](#coffeescript-format) section for slightly different \nsyntax (though more aesthetically appealing, I must admit). \n\n\n## row format\n\nSimilar to Cucumber and Spock, where.js data tables must contain at least two \nrows. The first row must contain the names to be used as variables in the \nexpectation. The remaining rows must contain data values for each name.  Values \nmust be separated by the pipe | character.\n\nFor example, `a`, `b`, and `c` are named as variables in the table, and used in \nthe expectation - without having to be declared explicitly with the `var` \nkeyword.\n\n    it('should pass with correct data and expectation', function () {\n      where(function(){\n        /***\n         a | b | c\n         1 | 2 | 2\n         4 | 3 | 4\n         6 | 6 | 6\n        ***/\n        \n        expect(Math.max(a, b)).toBe(c);\n      });\n    });\n\n    \n## borders\n\nTables may also optionally contain left and right edge borders, similar to \nCucumber and Fit:\n\n    it('should pass with left and right table borders', function () {\n      where(function(){\n        /***\n        | a | b | c |\n        | 1 | 2 | 2 |\n        | 4 | 3 | 4 |\n        | 6 | 6 | 6 |\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n      });\n    });\n\nFor empty cells, borders are required.\n\n## line comments\n\nTable rows may contain line comments.\n\n      where(function(){\n        /***\n        | a | b | c |\n        | 1 | 2 | 2 |  // should pass\n        | 4 | 3 | x |  // should fail\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n      });\n      \nA commented row is ignored.\n\n      where(function(){\n        /***\n          | a | b | c |\n          | 1 | 2 | 2 | // should pass\n        //| 4 | 3 | x | (should not execute)\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n      });\n\n## string data vs. empty data\n\n### data with quoted strings are preserved\n\n    it('should handle quoted strings', function () {\n      where(function () {\n        /***\n          a  | b  | c    | d    | e   | f        | g           | h | normal \n          '' | \"\" | \"''\" | '\"\"' | ' ' | ' faff ' | 'undefined' |   |   a b   \n          ***/\n        expect(a).toBe('\\'\\'');\n        expect(b).toBe('\\\"\\\"');\n        expect(c).toBe('\\\"\\'\\'\\\"');\n        expect(d).toBe('\\'\"\\\"\\'');\n        expect(e).toBe('\\' \\'');\n        expect(f).toBe('\\' faff \\'');\n        expect(g).toBe('\\'undefined\\'');\n        expect(h).toBe('');         // empty boxes are empty strings\n        expect(normal).toBe('a b'); // unquoted values are strings\n      });\n    });\n    \n### *empty* data should be delimited with separators:\n\n      it('should throw when empty data missing separators', function() {\n        expect(function() {\n          where(function() {\n            /***\n             a \n                // interpreted as missing row, not as row with empty data\n            ***/\n            expect(a).toBe('');\n          });\n        }).toThrow();\n      });\n      \n      it('should not throw when empty data is separated', function() {\n        where(function() {\n          /***\n          | a |\n          |   | // interpreted as row with empty data\n          ***/\n          expect(a).toBe('');\n        });\n      });\n      \n## numeric data vs numeric string\n\n### numeric data is automatically converted to the `Number` type\n\nThat enables you to type `Math.max(a, b)` to avoid re-typing coercions such as \n`Math.max(Number(a), Number(b))`.\n\nThat also means every test can use strict equality, so you don't need to rely \non regular expression matchers when getting started.\n\n_However_, where `Math` is involved there is usually an octal, signed, comma, or \nprecision bug waiting.  where.js handles all but precision automatically.  You \ncan get precision into your tests by adding another column, as seen in the test \ncreated to verify that numeric conversions work:\n\n      where(function(){\n      \n        /***\n          a        | b      | c       | p\n              \n          0        | 1      | 1       | 1\n          0.0      | 1.0    | 1       | 1\n          -1       | +1     | 0       | 1\n          +1.1     | -1.2   | -0.1    | 2\n          08       | 08     | 16      | 2\n          6        | 4      | 10.0    | 3\n          8.030    | -2.045 | 5.985   | 4\n          1,000.67 | 1345   | 2345.67 | 6\n          5        | 5      | 10      | 1\n          ***/\n        \n        /*\n         * using precision for famous .1 + .2 == 0.30000000000000004 \n         * and 5.985 vs 5.98499999999999999999999999 bugs \n         */\n \n        var s = (a + b).toPrecision(p);\n        \n        /*\n         * toPrecision() returns a string, so the prefixed '+' uses implicit \n         * conversion to number.\n         */\n         \n        expect(+s).toBe(c);\n      });\n\n### numeric strings are preserved\n\n      where(function () {\n        /***\n          date        | dataString   | number | numberString\n          1973-01-01  | '2014-01-01' | 2      | '4'\n          ***/\n        expect(date).toBe('1973-01-01');\n        expect(dataString).toBe('\\'2014-01-01\\'');\n        expect(number).toBe(2);\n        expect(numberString).toBe('\\'4\\'');\n      });\n      \n      \n## null, undefined, boolean values\n\nTruthy/falsy values are also automatically converted as per this test:\n\n      where(function () {\n        /***\n          a    | b         | c     | d\n          null | undefined | false | true\n        ***/\n        \n        expect(a).toBe(null);\n        expect(b).toBe(undefined);\n        expect(c).toBe(false);\n        expect(d).toBe(true);\n      });\n\n      \n## output\n\nA passing `where()` test has no effect on the test runner's default reporter \noutput.\n\nWhen an expectation fails, the data-table labels plus the row of values for the \ncurrent expectation are added to the *current* failing item. Every failed \nexpectation in a `where()` test will appear similar to:\n\n    [a | b | c] : \n    [1 | 2 | x] (Error: Expected 2 to be 'x'.)\n\n    \n## results\n\n`where()` returns a `results` object with arrays for `labels` and `values` \nderived from the data table, `passing` tests, and `failing` tests.\n\nThe following snip shows how to refer to each array in the results:\n\n    it('should pass with correct data and expectation', function () {\n      var results = where(function(){\n        /***\n         a | b | c\n         1 | 2 | 2\n         4 | 3 | 4\n         6 | 6 | 6\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n      });\n      \n      expect(results.data.labels.join(',')).toBe(\"a,b,c\");\n      expect(results.data.values.length).toBe(3);\n      expect(results.passing.length).toBe(3);\n      expect(results.failing.length).toBe(0);\n    });\n\n## context specifier\n\n__THIS IS THE CRITICAL \"LIBRARY-AGNOSTIC\" PIECE OF THE PUZZLE.__\n\n`where()` accepts up to two arguments. The first is the function containing the \ndata table and assertions.  \n\nThe second, optional but _recommended_, argument is a `context` or configuration \nobject that allows you to specify the test strategy (or library) in use, and \npass non-global items to the test function (a library's assert or expect or test \nmethod, e.g.).\n\nThe following snip shows that `context` is itself made available for inspection \ninside the test function:\n\n      where(function(){\n        /***\n         a | b | c\n         0 | 0 | 0\n        ***/\n        \n        expect(context.expect).toBe(expect);\n        \n      }, { expect: expect }); // <= context\n\n### log\n     \nNormal logging occurs mainly with failing tests. You can set a nonce property on \nthe context specifier as `log: 1` to enable logging of *all* test output to the \nconsole.\n\n      where(function(){\n        /***\n         a | b | c\n         1 | 2 | 2\n         4 | 3 | 4\n         6 | 6 | 6\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n        \n      }, { log: 1, expect: expect });\n      \nFailed tests or errors will appear as\n\n    [a | b | c] : \n    [1 | 2 | x] (Error: Expected 2 to be 'x'.)\n     \nPassing tests will appear as\n\n    [a | b | c] : \n    [1 | 2 | 2] (Passed)\n     \n\n### intercept\n\nNot all test libraries support \"fail\" in the same way - that is, while some \ntests \"should\" fail, a library may report the test as failed even though the \nfailure is expected.  To prevent expected failures from appearing *as failed* in \na test library's reporter (make a fail into a pass), you can set a nonce \nproperty on the context specifier as `intercept: 1` and verify the number of \nexpected failures in the results returned by `where()`:\n\n      var results = where(function(){\n        /***\n         a | b | c\n         1 | 2 | 2\n         4 | 3 | x\n         6 | 6 | 6\n        ***/\n        expect(Math.max(a, b)).toBe(c);\n        \n      }, { intercept: 1, expect: expect });\n      \n      expect(results.data.labels.join(',')).toBe(\"a,b,c\");\n      expect(results.data.values.length).toBe(3);\n      expect(results.passing.length).toBe(2);\n      expect(results.failing.length).toBe(1);\n      \n\n__ISSUE__: In logging-event-based libraries like QUnit and tape, pure \ninterception is not always successful - an assertion that fails inside a `where` \nclause will almost always be reported as failed. This behavior will be visited \nmore thoroughly in the refactoring of the `strategy` API (see next section...).\n\n\n### strategy\n\nwhere.js comes with several strategies pre-defined for each testing library \nsupported initially.  The default strategy is a basic try+catch used by mocha. \n__You do not need to specify a strategy when using mocha.__ \n\nA strategy can be specified in one of two ways:\n\n+ use `{ strategy: '<quoted-name>' }` \n  - if the name is available as a global variable (this is true for jasmine)\n  - if you do not need a reference to that object (that is true for nodeunit).\n+ use `{ <name>: <named-object-reference> }` \n  - when the name is not a global, *and/or...* \n  - when your strategy needs a reference to the object (this is true for QUnit \n    and for tape).\n\n#### mocha (default)\n\nThe default strategy is a basic try+catch used by mocha. __You do not need to \nspecify a strategy when using mocha.__ \n\n+ `{ strategy: 'mocha' }`\n+ `{ mocha: mocha }` (use this when `mocha` is defined elsewhere in your tests \n    and you wish to use it within the test function itself)\n\nHowever, unless you are using `should.js`, you must specify which assertion \nmethod your test relies on:\n\n+ `{ expect: expect }`\n+ `{ assert: assert }`\n+ `{ expect: chai.expect }`\n+ `{ assert: chai.assert }`\n\n(Both mocha's should.js and chai's should.js add a `should` method to \n`Object.prototype`, brilliantly making every object assertable - except those, \nnot surprisingly, created by the `Object.create()` method.)\n\nThe mocha `assert` browser tests in this repo rely on \n[assert.js](http://github.com/Jxck/assert), \"a port of the Node.js standard \nassertion library for the browser.\"\n\n#### jasmine\n\nTo use the jasmine strategy, add the following to your node suite:\n\n    require('[path/to/]/strategy/jasmine-strategy.js');\n  \nBecause jasmine also uses a try+catch approach, you do not need to specify \njasmine as the test strategy.  However, it is *recommended if you want to \nintercept failing test messages*:\n\n+ `{ strategy: 'jasmine' }` when jasmine is defined globally (node, browsers)\n+ `{ jasmine: jasmine }` when you need to use jasmine within the where function.\n\n#### nodeunit\n\nTo use the nodeunit strategy, add the following to your node suite:\n\n    require('[path/to/]/strategy/nodeunit-strategy.js');\n  \nThe nodeunit strategy does not use a reference to the nodeunit object, so you \nneed only use the strategy string approach in your tests:\n\n    { strategy: 'nodeunit' }\n    \nWhen you need to use nodeunit within the where() function specify nodeunit with:\n\n    { nodeunit: nodeunit }\n\n\n#### QUnit\n\nTo use the QUnit strategy, add the following to your node suite:\n\n    require('[path/to/]/strategy/qunit-strategy.js');\n    \nWhen using QUnit, specify the QUnit strategy as follows:\n\n+ `{ QUnit: QUnit }` (QUnit is defined globally in both node and browsers)\n\nThe QUnit tests in this repo rely on \n[qunit-tap](//https://github.com/twada/qunit-tap), \"A TAP Output Producer Plugin \nfor QUnit.\"\n\n#### tape\n\nTo use the tape strategy, add the following to your node suite:\n\n    require('[path/to/]/strategy/tape-strategy.js');\n    \nFor use with tape, specify the tape strategy as follows:\n\n+ `{ tape: [test | t] }` \n\nwhere `test` or `t` refers to the test function passed in to each tape test:\n\n    var test = require('tape');\n\n    test('should pass tape context', function(t) { // t is test, test is tape...\n          \n      var results = where(function(){\n        /***\n        | a | b | c |\n        | 0 | 0 | 0 |\n        ***/\n        \n        // use the context reference to 'tape' to test itself\n        tape.equal(tape, context.tape, 'should find tape');\n\n      }, { tape: t });  // <= context\n      \n      t.equal(results.passing.length, 1);\n      t.end();\n    });\n\n    \nA copy of my [dom-console](https://github.com/dfkaye/dom-console) library is \nincluded in the browser suite for tape, and can be found in the \n[test/util](/test/util) folder. The dom-console merely writes `console.log()` \nstatements to a list in the DOM.\n\n\n### custom strategy \n\nYou can define your own strategy for a different library than those supported by \nwhere.js. \n\n+ call `where.strategy(name, fn);`\n  + `name` is the name of your target test runner (not the expectation library).\n  + `fn` is an initializer or seed function that should return another function \n    ~ which in turn is to be called on each row of where-data.\n    \nThe following boilerplate shows how to do this.\n\n    where.strategy(name, function nameStrategy(context) {\n    \n      // vars and references\n      \n      return function nameTest(fnTest, test, value) {\n        \n        // pre-process blocks here\n        \n        fnTest.apply({}, [context].concat(value));\n        \n        // post-process\n        \n        if (error) {\n          test.result = 'there was an error';\n        }\n      };\n    });\n\nThe 'nameStrategy' function is the initializer, and accepts a `context` argument \nthat refers to the context specifier object in where() calls.\n\nThe returned 'nameTest' function should accept these three parameters:\n\n+ `fnTest`, the wrapped test function that executes once per each \n  row of where-data\n+ `test`, the current test iteration, for collecting results\n+ `values`, an array containing the labels used as variables in each test\n\nThe post-process block is where to capture failing results and add them to the \n`test` object's `.result` property.\n\nBeyond this, it's best to look at the various strategy implementations to see \nwhich approach would suit your needs.  These are located in the \n[strategy](./strategy) directory.\n\n\n## CoffeeScript format\n\nAs of Jan 2014, the 3-asterisk comment sequences and line comments are the only \nitems not directly translatable to CoffeeScript.  \n\n### embedded table with backticks\n\nOne workaround is to use CoffeeScript's mechanism for \n[embedded JavaScript](http://coffeescript.org/#embedded) by placing backtick \n( \\` ) characters before the start `/***` and after the end `***/` comment\nsequences.\n\n      where ->\n      \n        `/***\n        \n         a | b | c\n         1 | 2 | 2\n         4 | 3 | 4\n         6 | 6 | 6\n         \n        ***/`\n        \n        expect(Math.max(a, b)).toBe c\n      \n### triple quote comments\n\nYou can also use the triple-quote multi-line string supported by CoffeeScript. \n\n    where ->\n      \"\"\"\n      a | b | c\n      1 | 2 | 3\n      4 | 5 | 9\n      \"\"\"\n      expect(a + b).toBe(c)\n      \nwhich compiles to\n\n    where(function() {\n      \"a | b | c\\n1 | 2 | 3\\n4 | 5 | 9\";\n      return expect(a + b).toBe(c);\n    });\n \n*__Thanks to [Jason Karns](https://github.com/jasonkarns)__, for this \nsuggestion* ~ this is a nicer approach.\n    \nTo intercept expected failures (using jasmine in this case), this CoffeeScript:\n\n       results = where ->\n         \"\"\"\n         a | b | c\n         1 | 2 | 3\n         4 | 5 | 6\n         \"\"\"\n         expect(a + b).toBe(c)\n               \n       , { jasmine: jasmine, expect: expect, intercept: 1 }\n       \n       expect(results.failing.length).toBe(1)\n       expect(results.passing.length).toBe(1)\n\ncompiles to:\n\n      var results;\n\n      results = where(function() {\n        \"a | b | c\\n1 | 2 | 3\\n4 | 5 | 6\";\n        return expect(a + b).toBe(c);\n      }, {\n        jasmine: jasmine,\n        expect: expect,\n        intercept: 1\n      });\n\n      expect(results.failing.length).toBe(1);\n\n      expect(results.passing.length).toBe(1);\n\nwhich is good enough for now.\n\n### line comments\n\nLine comments inside the multi-line comment are not removed by the CoffeeScript \ncompiler, but `where()` will parse for this situation.\n\nIn other words, this Coffeescript:\n\n      where ->\n        \"\"\"\n        a | b | c\n      # 1 | 2 | 3 # should be removed\n        4 | 5 | 9\n        \"\"\"\n        expect(a + b).toBe(c)\n        \ncompiles to\n\n      where(function() {\n      \n        \"a | b | c\\n# 1 | 2 | 3 # should be removed\\n4 | 5 | 9\";\n        \n        return expect(a + b).toBe(c);\n      });\n      \nand `where()` will replace the characters from `#` to `\\n` to:\n\n    \"a | b | c\\n 4 | 5 | 9\";\n\n      \n## tests\n\nThe goal of making where.js run in \"any\" test framework required making numerous \nversions of test suites.  Here's how they stack up:\n\n+ where.js core functionality tests using jasmine-node\n  - `npm test`\n  - `node jasmine-node --verbose ./test/where/where.spec.js`\n\n+ framework strategy comparison tests on node.js\n  - `npm run jasmine`\n  - `npm run mocha`\n  - `npm run nodeunit`\n  - `npm run qunit`\n  - `npm run tape`\n\n### testem\n\nI'm using Toby Ho's (@airportyh) MAGNIFICENT \n[testem](https://github.com/airportyh/testem) to drive tests in node.js and in \nmultiple browsers.\n\nThe core tests use \n[jasmine-2.0.0](http://jasmine.github.io/2.0/introduction.html) (which requires \ntestem v0.6.3 or later) in browsers, and Misko Hevery's (@mhevery)\n[jasmine-node](https://github.com/mhevery/jasmine-node) (which uses jasmine \n1.3.1 internally) on node.js.\n\nThe `testem.json` file defines launchers for the different frameworks for both \nnode.js and browser suites:\n\n+ `testem -l where` (core tests using jasmine)\n+ `testem -l jasmine` \n+ `testem -l mocha`\n+ `testem -l nodeunit`\n+ `testem -l qunit`\n+ `testem -l tape` (runs browserify on the tape suite)\n\n### npm testem scripts\n\nThe `package.json` file defines scripts to call the testem launchers (with the \nappropriate browser test page for each):\n\n+ `npm run testem` (core tests using jasmine)\n+ `npm run testem-jasmine`\n+ `npm run testem-mocha`\n+ `npm run testem-nodeunit`\n+ `npm run testem-qunit`\n+ `npm run testem-tape`\n\n### browser suites (and rawgithub)\n\nThe `browser-suites` rely on browser versions of each library stored in the \n[vendor](./vendor) directory (mocha, expect.js, assert.js, should, \nchai, qunit, qunit-tap, and jasmine-2.0.0), rather than your system's `/testem` \ndirectory, so they can be viewed as static pages.  \n\nYou can view them directly on rawgithub:\n\n+ [core suite](https://rawgithub.com/dfkaye/where.js/master/test/where/browser-suite.html)\n+ [jasmine](https://rawgithub.com/dfkaye/where.js/master/test/jasmine/browser-suite.html)\n+ [mocha et al.](https://rawgithub.com/dfkaye/where.js/master/test/mocha/browser-suite.html)\n+ [nodeunit](https://rawgithub.com/dfkaye/where.js/master/test/nodeunit/browser-suite.html)\n+ [QUnit with qunit-tap](https://rawgithub.com/dfkaye/where.js/master/test/qunit/browser-suite.html)\n+ [tape with browserified source](https://rawgithub.com/dfkaye/where.js/master/test/tape/browser-suite.html)\n\n\n### custom adapter for nodeunit with testem\n\nAdding a custom adapter for nodeunit to work in testem took half a day to get \ncompletely wrong, then a second half-day to get correct. The file is at \n[vendor/testem/nodeunit-adapter.js](./vendor/testem/nodeunit-adapter.js)\n\n\n## conclusions so far  \n\nI started with jasmine-where back when (October 2013) as a self-assessment and \nfound both v1.3.1 and v2.0.0-rc3 were a bit tricky but not difficult to \nintercept.  With jasmine 2.0.0 (first stable in late December) a fundamental \nfeature was no longer exposed (the currentSpec) which led to - shockingly - \nsimplifying my own jasmine-where and jasmine-intercept projects.  Thinking I was \njust not that great at this anymore, I took on the whole `where.js` concept in \nJanuary 2014 to invalidate that bit of self-doubt in a hurry.\n\n__what I found out__\n\nTest libraries make assumptions.  Not all test libraries are designed with the \nsame \"lifecycle\" in mind, meaning they do not expose hooks at identical stages. \nWhen adding message interception support, I found in more than one case that \nthere is no 'after-test-but-before-result' hook that would allow me to scrub \nexpected failures from the reporter.  \n\nThat indicates some library output reporters are tightly coupled with their test \nrunners.  *Which means some libraries themselves may not benefit from their own \nstated purpose - to ease test-driven development.*\n\nIn addition, not all *browsers* handle the test lifecycle the same way.  This \nwas not a surprise so much as annoyance.  For example, in the QUnit suite, IE, \nChrome and Opera report two failures whereas Firefox reports only one.  However, \nthese failures are expected so we really want to see NO failures because we're \ntrying to intercept them before QUnit sends them to the reporter.  QUnit also \nreported the failures *first* in the console, regardless of their occurrence in \nthe test suite.  (That could be a side-effect of using qunit-tap, however.)\n\nQUnit was surprisingly easy to hook *some* information, but impossible to trap \ncompletely.  You can force a failing result in QUnit with this:\n\n    QUnit.push(false, 'actual', 'expected', 'force fail message');\n    \nBut QUnit's legacy lifecycle doesn't expose a way for testers to intercept \nmessages to the HTML reporter (which is just visual rather than logical \ninspection anyway).  So I recommend using it with another reporting utility like \nqunit-tap so that you can ignore the \"should fail\" results in the HTML reporter. \n\nSame goes for Tape except that there is no HTML reporter for it, as it is a test \nlibrary for node.js projects.  To run tape in the browser, you need \n[browserify](http://browserify.org/). That's a minor benefit if you prefer the \nterse syntax of tape. If your emphasis is on browser capabilities rather than \nnode.js, tape should not be your first choice.\n\nMocha was even easier to work with, probably due to TJ's (@tjholowaychuk) early \ndecision to de-couple the assertion system completely from the test runner and \nreporter.  Taking assert, expect and should to the browser required only one \nlibrary to be ported - assert.js.  Working with chai was even easier - no port \nneeded for the browser. \n\nThe browser version that ships with nodeunit is based on an earlier version of \nthat library.  After trying the `make` command on it in my Windows setup and \nfinding yet again that some people just can't be bothered to test anything on \nWindows, I've updated the key methods with the proper versions in the core \nlibrary.  That's in the [vendor/nodeunit](./vendor/nodeunit) directory.\n\n\n## TODO\n\n+ clean up the procedural long-method setup code in the where() function\n+ clean up the procedural verbose documentation\n   \n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dfkaye/where.js/issues"
  },
  "_id": "where.js@0.0.13",
  "_shasum": "e6fbfdebe55ec99835461e09042797daf50b09e6",
  "_resolved": "git+https://git@github.com/cengebretson/where.js.git#dad0ae0407033610097e39524e484d937ca9f6b6",
  "_from": "where.js@git+https://git@github.com/cengebretson/where.js.git"
}
